// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

generator dbml {
  provider              = "prisma-dbml-generator"
  output                = "."
  projectName           = "Econominhas"
  projectDatabaseType   = "PostgreSQL"
  projectNote           = "The best way to manage your finances"
  includeRelationFields = false
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

//
//
// Accounts
//
//

enum SignInProviderEnum {
  GOOGLE

  @@map("sign_in_provider_enum")
}

/// Contains user's sign in information
model Account {
  id        String   @id @db.Char(16)
  email     String?  @unique @db.VarChar(150)
  phone     String?  @unique @db.VarChar(25)
  createdAt DateTime @default(now()) @map("created_at")

  config                    Config                     @relation(fields: [id], references: [accountId], map: "Config_id_fkey", onDelete: Restrict)
  magicLinkCode             MagicLinkCode?             @relation(fields: [id], references: [accountId], map: "MagicLinkCode_id_fkey", onDelete: Restrict)
  signInProviders           SignInProvider[]
  refreshTokens             RefreshToken[]
  userSubscriptions         UserSubscription[]
  termsAndPoliciesAccepteds TermsAndPoliciesAccepted[]
  bankAccounts              BankAccount[]
  cards                     Card[]
  categories                Category[]
  budgets                   Budget[]
  transactions              Transaction[]
  recurrentTransactions     RecurrentTransaction[]

  @@map("accounts")
}

/// Contains user's link to sign in providers, like google, discord, etc
model SignInProvider {
  accountId    String             @map("account_id") @db.Char(16)
  provider     SignInProviderEnum
  providerId   String             @map("provider_id") @db.VarChar(50)
  accessToken  String             @map("access_token") @db.VarChar(150)
  refreshToken String             @map("refresh_token") @db.VarChar(150)
  expiresAt    DateTime           @map("expires_at")

  account Account @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@id([accountId, provider, providerId])
  @@map("sign_in_providers")
}

/// Contains user's account config
model Config {
  accountId       String  @id @map("account_id") @db.Char(16)
  name            String? @db.VarChar(20)
  currentBudgetId String? @unique @map("current_budget_id") @db.Char(16)
  salaryId        String? @unique @map("salary_id") @db.Char(16)

  account       Account?
  currentBudget Budget?               @relation(fields: [currentBudgetId], references: [id])
  salary        RecurrentTransaction? @relation(fields: [salaryId], references: [id])

  @@map("configs")
}

/// Contains codes to be used by the users to login
model MagicLinkCode {
  accountId     String   @id @map("account_id") @db.Char(16)
  code          String   @db.Char(32)
  isFirstAccess Boolean  @map("is_first_access")
  createdAt     DateTime @default(now()) @map("created_at")

  account Account?

  @@map("magic_link_codes")
}

/// Contains codes to be used to refresh the access token
model RefreshToken {
  accountId    String   @map("account_id") @db.Char(16)
  refreshToken String   @unique @map("refresh_token") @db.Char(64)
  createdAt    DateTime @default(now()) @map("created_at")

  account Account? @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@id([accountId, refreshToken])
  @@map("refresh_tokens")
}

//
//
// Subscriptions
//
//

/// Contains information about the subscriptions
model Subscription {
  id                    String  @id @db.Char(16)
  name                  String  @db.VarChar(30)
  icon                  String  @db.VarChar(50)
  color                 String  @db.Char(7)
  iconColor             String  @map("icon_color") @db.Char(7)
  monthlyPrice          Int     @map("monthly_price") @db.SmallInt
  yearlyPrice           Int     @map("yearly_price") @db.SmallInt
  // Number limits
  bankAccounts          Int     @map("bank_accounts") @db.SmallInt /// -1 = Infinite
  postpaidCard          Int     @map("postpaid_card") @db.SmallInt /// -1 = Infinite
  prepaidCard           Int     @map("prepaid_card") @db.SmallInt /// -1 = Infinite
  categories            Int     @db.SmallInt /// -1 = Infinite
  transactionsPerMonth  Int     @map("transactions_per_month") @db.SmallInt /// -1 = Infinite
  recurrentTransactions Int     @map("recurrent_transactions") @db.SmallInt /// -1 = Infinite
  reports               Int     @db.SmallInt /// -1 = Infinite
  tags                  Int     @db.SmallInt /// -1 = Infinite
  reminders             Int     @db.SmallInt /// -1 = Infinite
  bankIntegrations      Int     @map("bank_integrations") @db.SmallInt /// -1 = Infinite
  budgets               Int     @db.SmallInt /// -1 = Infinite
  // Boolean limits
  web                   Boolean /// If the user has access to the web version
  ctlBpm                Boolean @map("ctl_bpm") /// Control budget per month: If allows the user to have a more precisa control over his budget, allowing him to edit each months budget, or he can only defines 1 value for all months of the year

  userSubscriptions UserSubscription[]

  @@map("subscriptions")
}

/// Contains the user's subscription
model UserSubscription {
  id             String    @id @db.Char(16)
  accountId      String    @map("account_id") @db.Char(16)
  subscriptionId String    @map("subscription_id") @db.Char(16)
  startedAt      DateTime  @default(now()) @map("started_at")
  lastRenewalAt  DateTime? @map("last_renewal_at")
  cancelledAt    DateTime? @map("cancelled_at") /// The base subscription will never have a cancelled_at, it will ALWAYS be active

  account      Account      @relation(fields: [accountId], references: [id], onDelete: Restrict)
  subscription Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Restrict)

  @@map("user_subscriptions")
}

//
//
// Terms of service
//
//

/// Contains the terms of use and privacy policy
model TermsAndPolicies {
  semVer        String    @id @map("sem_ver") @db.Char(5)
  termsOfUse    String    @map("terms_of_use") @db.VarChar(10000)
  privacyPolicy String    @map("privacy_policy") @db.VarChar(10000)
  liveAt        DateTime? @map("live_at")
  createdAt     DateTime  @default(now()) @map("created_at")

  termsAndPoliciesAccepteds TermsAndPoliciesAccepted[]

  @@map("terms_and_policies")
}

/// Contains the record of all the terms accepted by the user
model TermsAndPoliciesAccepted {
  accountId  String   @map("account_id") @db.Char(16)
  semVer     String   @map("sem_ver") @db.Char(5) /// Terms and policies ID
  acceptedAt DateTime @default(now()) @map("accepted_at")

  account          Account          @relation(fields: [accountId], references: [id], onDelete: Cascade)
  termsAndPolicies TermsAndPolicies @relation(fields: [semVer], references: [semVer], onDelete: Restrict)

  @@id([accountId, semVer])
  @@map("terms_and_policies_accepteds")
}

//
//
// Banks
//
//

/// Contains the record of all the existent banks
model BankProvider {
  id      String @id @db.Char(16)
  name    String @db.VarChar(30)
  code    String @db.Char(3)
  iconUrl String @map("icon_url") @db.VarChar(200)
  color   String @db.Char(7)

  bankAccounts  BankAccount[]
  cardProviders CardProvider[]

  @@map("bank_providers")
}

/// Contains the record of all the user's banks accounts
model BankAccount {
  id             String   @id @db.Char(16)
  accountId      String   @map("account_id") @db.Char(16)
  bankProviderId String   @map("bank_provider_id") @db.Char(16)
  name           String   @db.VarChar(30)
  accountNumber  String   @map("account_number") @db.Char(6)
  branch         String   @db.Char(4)
  balance        Int
  createdAt      DateTime @default(now()) @map("created_at")

  account                   Account                @relation(fields: [accountId], references: [id], onDelete: Cascade)
  bankProvider              BankProvider           @relation(fields: [bankProviderId], references: [id], onDelete: Restrict)
  transactions              Transaction[]          @relation(name: "TransactionBankAccount")
  transactionFroms          Transaction[]          @relation(name: "TransactionBankAccountFrom")
  transactionTos            Transaction[]          @relation(name: "TransactionBankAccountTo")
  recurrentTransactions     RecurrentTransaction[] @relation(name: "RecurrentTransactionBankAccount")
  recurrentTransactionFroms RecurrentTransaction[] @relation(name: "RecurrentTransactionBankAccountFrom")
  recurrentTransactionTos   RecurrentTransaction[] @relation(name: "RecurrentTransactionBankAccountTo")

  @@unique([accountId, bankProviderId, accountNumber])
  @@map("bank_accounts")
}

//
//
// Cards
//
//

enum CardTypeEnum {
  CREDIT
  VA
  VR
  VT

  @@map("card_type_enum")
}

enum CardNetworkEnum {
  VISA
  MASTERCARD
  ELO
  SODEXO

  @@map("card_network_enum")
}

/// Contains the record of all the existent cards
model CardProvider {
  id             String          @id @db.Char(16)
  bankProviderId String          @map("bank_provider_id") @db.Char(16)
  name           String          @db.VarChar(30)
  iconUrl        String          @map("icon_url") @db.VarChar(200)
  color          String          @db.Char(7)
  type           CardTypeEnum
  network        CardNetworkEnum
  statementDays  Int             @map("statement_days") @db.SmallInt /// Only postpaid cards have this column

  bankProvider BankProvider @relation(fields: [bankProviderId], references: [id], onDelete: Restrict)
  cards        Card[]

  @@map("card_providers")
}

/// Contains the record of all the user's cards
model Card {
  id             String  @id @db.Char(16)
  accountId      String  @map("account_id") @db.Char(16)
  cardProviderId String  @map("card_provider_id") @db.Char(16)
  name           String  @db.VarChar(30)
  lastFourDigits String  @map("last_four_digits") @db.Char(4)
  // Postpaid cards
  dueDay         Int?    @map("due_day") @db.SmallInt /// Only postpaid cards have this column
  limit          Int? /// Only postpaid cards have this column
  rtBillId       String? @map("rt_bill_id") @db.Char(16) /// Only postpaid cards have this column, Used to know the ID of the recurrent transaction that generate the transactions to pay the bill
  // Prepaid cards
  balance        Int? /// Only prepaid cards have this column

  account               Account                @relation(fields: [accountId], references: [id], onDelete: Cascade)
  cardProvider          CardProvider           @relation(fields: [cardProviderId], references: [id], onDelete: Restrict)
  transactions          Transaction[]
  rtBill                RecurrentTransaction?  @relation(name: "RecurrentTransactionRtBill", fields: [rtBillId], references: [id], onDelete: SetNull)
  recurrentTransactions RecurrentTransaction[]

  @@unique([cardProviderId, lastFourDigits])
  @@unique([rtBillId])
  @@map("cards")
}

//
//
// Categories
//
//

enum IconEnum {
  house
  shopping_cart @map("shopping-cart")
  baby
  tv
  medkit
  kiss
  suitcase
  beach
  question
  upload
  download
  transfer
  ad
  crown
  pencil
  logout
  trashcan
  pluscircle
  google
  email
  phone
  invoice
  plus
  wallet
  gear
  arrow_left    @map("arrow-left")
  less_than     @map("less-than")
  more_than     @map("more-than")
  triangle_down @map("triangle-down")
  info
  bank
  card
  ticket
  category
  pdf
  tag
  bell
  connect
  profile
  eye_slash     @map("eye-slash")
  clock
  computer
  calendar
  money_bag     @map("money-bag")

  @@map("icon_enum")
}

/// Contains the default categories suggested to the user on the account creation
model DefaultCategory {
  name        String   @id @db.VarChar(30)
  description String   @db.VarChar(300)
  icon        IconEnum
  color       String   @db.Char(7)

  @@map("default_categories")
}

/// Contains all the user's categories
model Category {
  id          String   @id @db.Char(16)
  accountId   String   @map("account_id") @db.Char(16)
  name        String   @db.VarChar(30)
  description String   @db.VarChar(300)
  icon        IconEnum
  color       String   @db.Char(7)
  active      Boolean

  account               Account                @relation(fields: [accountId], references: [id], onDelete: Cascade)
  budgetItems           BudgetItem[]
  transactions          Transaction[]
  recurrentTransactions RecurrentTransaction[]

  @@map("categories")
}

//
//
// Budgets
//
//

/// Contains the user's budget information
model Budget {
  id          String @id @db.Char(16)
  accountId   String @map("account_id") @db.Char(16)
  name        String @db.VarChar(30)
  description String @db.VarChar(300)

  account               Account                @relation(fields: [accountId], references: [id], onDelete: Cascade)
  recurrentTransactions RecurrentTransaction[]
  config                Config?
  budgetDates           BudgetDate[]

  @@map("budgets")
}

/// Contains the budgets information by date (month-year)
model BudgetDate {
  id       String @id @db.Char(16)
  budgetId String @map("budget_id") @db.Char(16)
  month    Int    @db.SmallInt
  year     Int    @db.SmallInt

  budget       Budget        @relation(fields: [budgetId], references: [id], onDelete: Cascade)
  budgetItems  BudgetItem[]
  transactions Transaction[]

  @@unique([budgetId, month, year])
  @@map("budget_dates")
}

/// Contains the user's budgets by category, month and year
model BudgetItem {
  budgetDateId String @map("budget_date_id") @db.Char(16)
  categoryId   String @map("category_id") @db.Char(16)
  amount       Int /// Can only be POSITIVE

  budgetDate BudgetDate @relation(fields: [budgetDateId], references: [id], onDelete: Cascade)
  category   Category   @relation(fields: [categoryId], references: [id], onDelete: Restrict)

  @@id([budgetDateId, categoryId])
  @@map("budget_items")
}

//
//
// Transactions
//
//

enum TransactionTypeEnum {
  IN /// Add money to bank account
  OUT /// Subtract from bank account immediately
  CREDIT /// Like OUT, but subtract from bank account only after bill is paid
  TRANSFER /// Removes money from an account and adds to another

  @@map("transaction_type_enum")
}

enum PaymentMethodEnum {
  CARD
  BANK_ACCOUNT

  @@map("payment_method_enum")
}

/// Contains all the user's transactions
model Transaction {
  id                     String              @id @db.Char(16)
  accountId              String              @map("account_id") @db.Char(16)
  type                   TransactionTypeEnum
  name                   String              @db.VarChar(30)
  description            String              @db.VarChar(300)
  amount                 Int /// Can only be POSITIVE, the real amount is determined by the type OUT/CREDIT, then amount * -1
  budgetDateId           String              @map("budget_date_id") @db.Char(16)
  createdAt              DateTime            @default(now()) @map("created_at")
  isSystemManaged        Boolean             @map("is_system_managed") /// Define if the transaction is automatic controlled by the system, or if it\'s created and controled by the user
  recurrentTransactionId String?             @map("recurrent_transaction_id") @db.Char(16)
  // Transaction type=IN,,CREDIT
  paymentMethod          PaymentMethodEnum?  @map("payment_method") /// Only type=IN,OUT,CREDIT transactions have this column
  categoryId             String?             @map("category_id") @db.Char(16) /// Only type=IN,OUT,CREDIT transactions have this column
  cardId                 String?             @map("card_id") @db.Char(16) /// Only type=IN,OUT,CREDIT transactions have this column
  bankAccountId          String?             @map("bank_account_id") @db.Char(16) /// Only type=IN,OUT,CREDIT transactions have this column
  // Transaction type=TRANSFER
  bankAccountFromId      String?             @map("bank_account_from_id") @db.Char(16) /// Only type=TRANSFER transactions have this column
  bankAccountToId        String?             @map("bank_account_to_id") @db.Char(16) /// Only type=TRANSFER transactions have this column

  account         Account      @relation(fields: [accountId], references: [id], onDelete: Cascade)
  budgetDate      BudgetDate?  @relation(fields: [budgetDateId], references: [id])
  // Transaction type=IN,OUT,CREDIT
  category        Category?    @relation(fields: [categoryId], references: [id], onDelete: Restrict)
  card            Card?        @relation(fields: [cardId], references: [id], onDelete: Restrict)
  bankAccount     BankAccount? @relation(name: "TransactionBankAccount", fields: [bankAccountId], references: [id], onDelete: Restrict)
  // Transaction type=TRANSFER
  bankAccountFrom BankAccount? @relation(name: "TransactionBankAccountFrom", fields: [bankAccountFromId], references: [id], onDelete: Restrict)
  bankAccountTo   BankAccount? @relation(name: "TransactionBankAccountTo", fields: [bankAccountToId], references: [id], onDelete: Restrict)

  installment Installment? @relation(fields: [id], references: [transactionId], onDelete: Restrict)

  @@map("transactions")
}

/// Contains the installment data of an transactions
model Installment {
  transactionId String   @id @map("transaction_id") @db.Char(16)
  total         Int      @db.SmallInt
  current       Int      @db.SmallInt
  createdAt     DateTime @default(now()) @map("created_at")

  transaction Transaction?

  @@map("installments")
}

//
//
// Recurrent Transactions
//
//

enum CaFormulaEnum {
  EXACT_AMOUNT
  MBWOPM /// MULTIPLY_BY_WEEKS_OF_PREV_MONTH, the amount is multiplied by the amount of weeks of the previous month
  MBDOPM /// MULTIPLY_BY_DAYS_OF_PREV_MONTH, the amount is multiplied by the amount of days of the previous month
  DPFET // DIFFERENT_PERCENTAGES_FOR_EACH_TRANSACTION, the "params" prop is an array of percentages matching each of the transactions that should be created. Using these parameters, the amount of the transaction will be multiplied by the percentage to get the final amount
  CCB // CREDIT_CARD_BILL, sum the value of the transactions to get the amount

  @@map("ca_formula_enum")
}

enum RecurrenceFrequencyEnum {
  DAILY /// Every day
  WEEKLY /// Every week
  MONTHLY /// Once a month
  SEMI_MONTHLY /// One month yes, another month no
  QUARTERLY /// Once every 3 months
  ANNUALLY /// Once a year @map("ANNUALLY")
  SEMI_ANNUALLY /// Once every 6 months

  @@map("recurrence_frequency_enum")
}

enum RecurrenceConditionsEnum {
  IN_WEEKDAY /// Mon-Fri
  IN_WEEKEND /// Sat-Sun
  IS_EVEN_DAY /// Like 2, 4, 6
  IS_ODD_DAY /// Like 1, 3, 5
  NOT_HOLIDAY
  IF_NOT_BEFORE /// If the day doesn't match the conditions, try previuoius days
  IF_NOT_AFTER /// If the day doesn't match the conditions, try following days

  @@map("recurrence_conditions_enum")
}

/// Contains all the user's recurrent transactions.
/// The recurrent transactions are linked to the budget, this way the user can have a better control of which transactions he wants to execute.
model RecurrentTransaction {
  id                String              @id @db.Char(16)
  accountId         String              @map("account_id") @db.Char(16)
  budgetId          String              @map("budget_id") @db.Char(16)
  isSystemManaged   Boolean             @map("is_system_managed") /// Define if the recurrent transaction is automatic controlled by the system, or if it\'s created and controled by the user
  // Data to create the transaction
  type              TransactionTypeEnum
  name              String              @db.VarChar(30)
  description       String              @db.VarChar(300)
  amount            Int /// Can only be POSITIVE, the real amount is determined by the type OUT/CREDIT, then amount * -1
  createdAt         DateTime            @default(now()) @map("created_at")
  isSystemManagedT  Boolean             @map("is_system_managed_t") /// Same as "isSystemManaged". It exists because some RecurrentTransactions may be system managed, but the Trasactions created by this RecurrentTransaction aren't. An example of it it's the salary, we have a specific interface for the user to managed it, and it shouldn't be managed directly by the user like other RecurrentTransactions, but the transactions created by it are normal Transactions, that the user can edit freely.
  // Transaction type=IN,OUT,CREDIT
  paymentMethod     PaymentMethodEnum?  @map("payment_method") /// Only type=IN,OUT,CREDIT transactions have this column
  categoryId        String?             @map("category_id") @db.Char(16) /// Only type=IN,OUT,CREDIT transactions have this column
  cardId            String?             @map("card_id") @db.Char(16) /// Only type=IN,OUT,CREDIT transactions have this column
  bankAccountId     String?             @map("bank_account_id") @db.Char(16) /// Only type=IN,OUT,CREDIT transactions have this column
  // Transaction type=TRANSFER
  bankAccountFromId String?             @map("bank_account_from_id") @db.Char(16) /// Only type=TRANSFER transactions have this column
  bankAccountToId   String?             @map("bank_account_to_id") @db.Char(16) /// Only type=TRANSFER transactions have this column

  account                   Account                    @relation(fields: [accountId], references: [id], onDelete: Cascade)
  budget                    Budget                     @relation(fields: [budgetId], references: [id], onDelete: Restrict)
  recurrentTransactionRules RecurrentTransactionRule[]
  config                    Config?
  // Transaction type=IN,OUT,CREDIT
  category                  Category?                  @relation(fields: [categoryId], references: [id], onDelete: Restrict)
  card                      Card?                      @relation(fields: [cardId], references: [id], onDelete: Restrict)
  cardToPayBill             Card?                      @relation(name: "RecurrentTransactionRtBill")
  bankAccount               BankAccount?               @relation(name: "RecurrentTransactionBankAccount", fields: [bankAccountId], references: [id], onDelete: Restrict)
  // Transaction type=TRANSFER
  bankAccountFrom           BankAccount?               @relation(name: "RecurrentTransactionBankAccountFrom", fields: [bankAccountFromId], references: [id], onDelete: Restrict)
  bankAccountTo             BankAccount?               @relation(name: "RecurrentTransactionBankAccountTo", fields: [bankAccountToId], references: [id], onDelete: Restrict)

  @@map("recurrent_transactions")
}

/// Contains the recurrent transactions rules to be executed
model RecurrentTransactionRule {
  id                     String @id @db.Char(16)
  recurrentTransactionId String @map("recurrent_transaction_id") @db.Char(16)

  caFormula    CaFormulaEnum              @map("ca_formula")
  caParams     String                     @map("ca_params") @db.VarChar /// JSON stringified prop to pass the params to calculate the amount
  caConditions RecurrenceConditionsEnum[] @map("ca_conditions")

  frequency   RecurrenceFrequencyEnum
  fParams     String                     @map("f_params") @db.VarChar /// JSON stringified prop to pass the params to calculate the frequency
  fConditions RecurrenceConditionsEnum[] @map("f_conditions")

  recurrentTransaction RecurrentTransaction @relation(fields: [recurrentTransactionId], references: [id])

  @@map("recurrent_transaction_rules")
}
